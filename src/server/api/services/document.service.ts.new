import { eq, and, or, like, desc, asc, count, gt } from "drizzle-orm";
import { db } from "@/server/db";
import { documents, employees, users } from "@/server/db/schema";
import type { DocumentFiltersInput } from "@/modules/documents/types";

export class DocumentsService {
  static async create(input: {
    title: string;
    description: string;
    url: string;
    type: string;
    visibility: string;
    uploadedBy: string;
    employeeId?: string;
  }) {
    const [document] = await db
      .insert(documents)
      .values({
        title: input.title,
        description: input.description,
        url: input.url,
        type: input.type as any, // Cast to enum type
        visibility: input.visibility as any, // Cast to enum type
        employeeId: input.employeeId || null,
        uploadedBy: input.uploadedBy,
      })
      .returning();

    return document;
  }

  static async update(input: {
    id: string;
    title: string;
    description: string;
    type: string;
    visibility: string;
    employeeId?: string;
  }) {
    const [document] = await db
      .update(documents)
      .set({
        title: input.title,
        description: input.description,
        type: input.type as any, // Cast to enum type
        visibility: input.visibility as any, // Cast to enum type
        employeeId: input.employeeId || null,
        updatedAt: new Date(),
      })
      .where(eq(documents.id, input.id))
      .returning();

    return document;
  }

  static async findById(id: string) {
    const result = await db
      .select({
        id: documents.id,
        title: documents.title,
        description: documents.description,
        url: documents.url,
        type: documents.type,
        visibility: documents.visibility,
        employeeId: documents.employeeId,
        isActive: documents.isActive,
        uploadedBy: documents.uploadedBy,
        createdAt: documents.createdAt,
        updatedAt: documents.updatedAt,
        employee: {
          id: employees.id,
          designation: employees.designation,
          department: employees.department,
        },
        author: {
          id: users.id,
          name: users.name,
          image: users.image,
        },
      })
      .from(documents)
      .leftJoin(employees, eq(documents.employeeId, employees.id))
      .leftJoin(users, eq(documents.uploadedBy, users.id))
      .where(eq(documents.id, id))
      .limit(1);

    if (!result[0]) return null;

    return result[0];
  }

  static async findMany(filters: DocumentFiltersInput = {
    limit: 20,
    offset: 0,
    sortBy: "createdAt",
    sortOrder: "desc"
  }) {
    const {
      type,
      visibility,
      search,
      employeeId,
      isActive = true,
      uploadedBy,
      limit = 20,
      offset = 0,
      sortBy = "createdAt",
      sortOrder = "desc",
      createdAfter,
    } = filters;

    // Build where conditions
    const whereConditions = [eq(documents.isActive, isActive)];

    if (type) {
      whereConditions.push(eq(documents.type, type as any));
    }

    if (visibility) {
      whereConditions.push(eq(documents.visibility, visibility as any));
    }

    if (employeeId) {
      whereConditions.push(eq(documents.employeeId, employeeId));
    }

    if (uploadedBy) {
      whereConditions.push(eq(documents.uploadedBy, uploadedBy));
    }

    if (createdAfter) {
      whereConditions.push(gt(documents.createdAt, createdAfter));
    }

    if (search) {
      whereConditions.push(
        or(
          like(documents.title, `%${search}%`),
          like(documents.description, `%${search}%`)
        )!
      );
    }

    // Build sort condition
    let sortColumn;
    
    // Handle column to sort by
    switch (sortBy) {
      case "title":
        sortColumn = documents.title;
        break;
      case "type":
        sortColumn = documents.type;
        break;
      case "createdAt":
      default:
        sortColumn = documents.createdAt;
        break;
    }
    
    const orderFn = sortOrder === "asc" ? asc : desc;

    // Get total count
    const totalResult = await db
      .select({ total: count() })
      .from(documents)
      .where(and(...whereConditions));

    const total = totalResult[0]?.total ?? 0;

    // If limit is 0, just return the count (used for statistics)
    if (limit === 0) {
      return {
        documents: [],
        total,
      };
    }

    // Get documents with relations
    const result = await db
      .select({
        id: documents.id,
        title: documents.title,
        description: documents.description,
        url: documents.url,
        type: documents.type,
        visibility: documents.visibility,
        employeeId: documents.employeeId,
        isActive: documents.isActive,
        uploadedBy: documents.uploadedBy,
        createdAt: documents.createdAt,
        updatedAt: documents.updatedAt,
        employee: {
          id: employees.id,
          designation: employees.designation,
          department: employees.department,
        },
        author: {
          id: users.id,
          name: users.name,
          image: users.image,
        },
      })
      .from(documents)
      .leftJoin(employees, eq(documents.employeeId, employees.id))
      .leftJoin(users, eq(documents.uploadedBy, users.id))
      .where(and(...whereConditions))
      .orderBy(orderFn(sortColumn))
      .limit(limit)
      .offset(offset);

    return {
      documents: result,
      total,
    };
  }

  static async delete(id: string) {
    const [document] = await db
      .update(documents)
      .set({
        isActive: false,
        updatedAt: new Date(),
      })
      .where(eq(documents.id, id))
      .returning();

    return document;
  }

  static async permanentDelete(id: string) {
    const [document] = await db
      .delete(documents)
      .where(eq(documents.id, id))
      .returning();

    return document;
  }
}
